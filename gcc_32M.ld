ENTRY(_reset)

ROMADDR = DEFINED(BOOTLOAD) ? 0x9FC00000 : 0x9D000000;
RAMADDR = 0x80000000;

RESET_ADDR = ( DEFINED(BOOTLOAD) || DEFINED(STANDALONE) ) ? 0x9FC00000 : ROMADDR;

PROVIDE(_ebase_address = ROMADDR + 0x1000);
PROVIDE(_stack = RAMADDR+RAMLEN-0x10);

MEMORY
{
  kseg0_boot_mem           : ORIGIN = RESET_ADDR,         LENGTH = 0x0480
  kseg0_boot_mem_4B0       : ORIGIN = RESET_ADDR+0x04B0,  LENGTH = 0x0800-0x04B0
  rom                (rx)  : ORIGIN = ROMADDR    +0x1000, LENGTH = ( DEFINED(BOOTLOAD) ? BOOTLEN : ROMLEN ) -0x1000
  ram               (w!x)  : ORIGIN = RAMADDR,            LENGTH = RAMLEN
  invalid                  : ORIGIN = 0,                  LENGTH = 0
  devcfg                   : ORIGIN = 0xBFC02FF0,         LENGTH = 0x10
}


SECTIONS
{

  /* Read-only sections, merged into text segment: */
  PROVIDE( _start = RESET_ADDR );
  . = ORIGIN(kseg0_boot_mem);

  .devcfg : {
    *(.devcfg)
  } > devcfg

  .invalid : {
    *(.interp)
    *(.MIPS.xhash)
    *(.dynamic)
    *(.hash)
    *(.gnu.hash)
    *(.dynsym)
    *(.dynstr)
    *(.gnu.version)
    *(.gnu.version_d)
    *(.gnu.version_r)
    *(.rel.init)
    *(.rel.text .rel.text.* .rel.gnu.linkonce.t.*)
    *(.rel.fini)
    *(.rel.rodata .rel.rodata.* .rel.gnu.linkonce.r.*)
    *(.rel.data.rel.ro .rel.data.rel.ro.* .rel.gnu.linkonce.d.rel.ro.*)
    *(.rel.data .rel.data.* .rel.gnu.linkonce.d.*)
    *(.rel.tdata .rel.tdata.* .rel.gnu.linkonce.td.*)
    *(.rel.tbss .rel.tbss.* .rel.gnu.linkonce.tb.*)
    *(.rel.ctors)
    *(.rel.dtors)
    *(.rel.got)
    *(.rel.sdata .rel.sdata.* .rel.gnu.linkonce.s.*)
    *(.rel.sbss .rel.sbss.* .rel.gnu.linkonce.sb.*)
    *(.rel.sdata2 .rel.sdata2.* .rel.gnu.linkonce.s2.*)
    *(.rel.sbss2 .rel.sbss2.* .rel.gnu.linkonce.sb2.*)
    *(.rel.bss .rel.bss.* .rel.gnu.linkonce.b.*)
    *(.rel.iplt)
    *(.rela.init)
    *(.rela.text .rela.text.* .rela.gnu.linkonce.t.*)
    *(.rela.fini)
    *(.rela.rodata .rela.rodata.* .rela.gnu.linkonce.r.*)
    *(.rela.data .rela.data.* .rela.gnu.linkonce.d.*)
    *(.rela.tdata .rela.tdata.* .rela.gnu.linkonce.td.*)
    *(.rela.tbss .rela.tbss.* .rela.gnu.linkonce.tb.*)
    *(.rela.ctors)
    *(.rela.dtors)
    *(.rela.got)
    *(.rela.sdata .rela.sdata.* .rela.gnu.linkonce.s.*)
    *(.rela.sbss .rela.sbss.* .rela.gnu.linkonce.sb.*)
    *(.rela.sdata2 .rela.sdata2.* .rela.gnu.linkonce.s2.*)
    *(.rela.sbss2 .rela.sbss2.* .rela.gnu.linkonce.sb2.*)
    *(.rela.bss .rela.bss.* .rela.gnu.linkonce.b.*)
    *(.rela.iplt)
    *(.rel.plt)
    *(.rela.plt)
    *(.plt)
    *(.iplt)
    *(.gptab.*)
    *(.data.rel.ro.local* .gnu.linkonce.d.rel.ro.local.*) *(.data.rel.ro .data.rel.ro.* .gnu.linkonce.d.rel.ro.*)
    *(.tdata .tdata.* .gnu.linkonce.td.*)
    *(.tbss .tbss.* .gnu.linkonce.tb.*) *(.tcommon)
    *(.jcr)
    *(.config_BFC*)
    *(.gcc_compiled_long32)
    *(.gcc_compiled_long64)
  } > invalid

  /* Boot Sections */
  .reset RESET_ADDR :
  {
    KEEP(*(.reset))
    KEEP(*(.reset.startup))
  } > kseg0_boot_mem

  .bev_excpt RESET_ADDR + 0x380 :   /* Boot exception Vector */
  {
    KEEP(*(.bev_handler))
  } > kseg0_boot_mem

  .app_excpt _ebase_address + 0x180 :
  {
    KEEP(*(.gen_handler))
  } > rom

  /* Interrupt vector table with vector offsets */
  .vectors _ebase_address + 0x200 :
  {
    /*  Symbol __vector_offset_n points to .vector_n if it exists,
     *  otherwise points to the default handler. The
     *  vector_offset_init.o module then provides a .data section
     *  containing values used to initialize the vector-offset SFRs
     *  in the crt0 startup code.
     */
    . = ALIGN(4) ;
    KEEP(*(.vector_table))
  } > rom

  .init ALIGN(16) :
  {
    KEEP (*(SORT_NONE(.init)))
  } > rom

  .text           :
  {
    _ftext = .;
    *(.text.unlikely .text.*_unlikely .text.unlikely.*)
    *(.text.exit .text.exit.*)
    *(.text.startup .text.startup.*)
    *(.text.hot .text.hot.*)
    *(SORT(.text.sorted.*))
    *(.text .stub .text.* .gnu.linkonce.t.*)

    . = ALIGN(4) ;
    *(.sdata2 .sdata2.* .gnu.linkonce.s2.*)
    . = ALIGN(4) ;
    *(.sbss2 .sbss2.* .gnu.linkonce.sb2.*)
    . = ALIGN(4) ;

    /* .gnu.warning sections are handled specially by elf.em.  */
    *(.gnu.warning)
    *(.mips16.fn.*) *(.mips16.call.*)
  } > rom

  .fini           :
  {
    KEEP (*(SORT_NONE(.fini)))
  } > rom

  PROVIDE (__etext = .);
  PROVIDE (_etext = .);
  PROVIDE (etext = .);

  .rodata         :
  {
    *(.rodata .rodata.* .gnu.linkonce.r.*)
    *(.rodata1)
    . = ALIGN(4) ;
  } > rom

  .eh_frame_hdr     : { *(.eh_frame_hdr) *(.eh_frame_entry .eh_frame_entry.*) }>rom
  .eh_frame         : ONLY_IF_RO { KEEP (*(.eh_frame)) *(.eh_frame.*)         }>rom
  .gcc_except_table : ONLY_IF_RO { *(.gcc_except_table .gcc_except_table.*)   }>rom
  .gnu_extab        : ONLY_IF_RO { *(.gnu_extab*)                             }>rom
  /* These sections are generated by the Sun/Oracle C++ compiler.  */
  .exception_ranges  : ONLY_IF_RO { *(.exception_ranges*)                     }>rom

  /* Adjust the address for the data segment.  We want to adjust up to
     the same address within the page on the next page up.  */
  . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));

  .build-id :
  {
    *(.note.gnu.build-id)
  } > rom

  .preinit_array    :
  {
    PROVIDE_HIDDEN (__preinit_array_start = .);
    KEEP (*(.preinit_array))
    PROVIDE_HIDDEN (__preinit_array_end = .);
  } >rom
  .init_array    :
  {
    PROVIDE_HIDDEN (__init_array_start = .);
    KEEP (*(SORT_BY_INIT_PRIORITY(.init_array.*) SORT_BY_INIT_PRIORITY(.ctors.*)))
    KEEP (*(.init_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .ctors))
    PROVIDE_HIDDEN (__init_array_end = .);
  } >rom
  .fini_array    :
  {
    PROVIDE_HIDDEN (__fini_array_start = .);
    KEEP (*(SORT_BY_INIT_PRIORITY(.fini_array.*) SORT_BY_INIT_PRIORITY(.dtors.*)))
    KEEP (*(.fini_array EXCLUDE_FILE (*crtbegin.o *crtbegin?.o *crtend.o *crtend?.o ) .dtors))
    PROVIDE_HIDDEN (__fini_array_end = .);
  } >rom
  .ctors          :
  {
    /* gcc uses crtbegin.o to find the start of
       the constructors, so we make sure it is
       first.  Because this is a wildcard, it
       doesn't matter if the user does not
       actually link against crtbegin.o; the
       linker won't look for a file to match a
       wildcard.  The wildcard also means that it
       doesn't matter which directory crtbegin.o
       is in.  */
    KEEP (*crtbegin.o(.ctors))
    KEEP (*crtbegin?.o(.ctors))
    /* We don't want to include the .ctor section from
       the crtend.o file until after the sorted ctors.
       The .ctor section from the crtend file contains the
       end of ctors marker and it must be last */
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))
    KEEP (*(SORT(.ctors.*)))
    KEEP (*(.ctors))
  } >rom
  .dtors          :
  {
    KEEP (*crtbegin.o(.dtors))
    KEEP (*crtbegin?.o(.dtors))
    KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))
    KEEP (*(SORT(.dtors.*)))
    KEEP (*(.dtors))
    . = ALIGN(4) ;
  } >rom

  _tdata = .; PROVIDE(_tdata = .);

  . = DATA_SEGMENT_RELRO_END (0, .);
  . = .;

  .eh_frame           : ONLY_IF_RW { KEEP (*(.eh_frame)) *(.eh_frame.*)       }>ram AT>rom
  .gnu_extab          : ONLY_IF_RW { *(.gnu_extab)                            }>ram AT>rom
  .gcc_except_table   : ONLY_IF_RW { *(.gcc_except_table .gcc_except_table.*) }>ram AT>rom
  .exception_ranges   : ONLY_IF_RW { *(.exception_ranges*)                    }>ram AT>rom

  .data :
  {
    _fdata = .;
    *(.data .data.* .gnu.linkonce.d.*)
    *(.data1)
    SORT(CONSTRUCTORS)
  } >ram AT>rom

  .got.plt ALIGN(4) :
  {
    *(.got.plt)
    . = ALIGN(4) ;
  } >ram AT>rom

  . = .;  _gp = ALIGN(16) + 0x7ff0;

  .got ALIGN(4) :
  {
    *(.got)
    *(.rel.dyn)
    . = ALIGN(4) ;
  } >ram AT>rom

  .sdata ALIGN(4) :
  {
    *(.sdata .sdata.* .gnu.linkonce.s.*)
    *(.lit8)
    *(.lit4)
  } >ram AT>rom

  . = ALIGN(4) ;
  _edata = .; PROVIDE (edata = .);
  . = .;
  __bss_start = .;
  _fbss = .;
  .sbss ALIGN(4) (NOLOAD) :
  {
    _sbss_begin = . ;
    *(.dynsbss)
    *(.sbss .sbss.* .gnu.linkonce.sb.*)
    *(.scommon)
    _sbss_end = . ;
    . = ALIGN(4) ;
  } >ram

  .bss (NOLOAD) :
  {
    _bss_begin = .;
    *(.dynbss)
    *(.bss .bss.* .gnu.linkonce.b.*)
    *(COMMON)
    . = ALIGN(. != 0 ? 32 / 8 : 1);
    _bss_end = .;
  } >ram

  . = ALIGN(32 / 8);
  _end = .; PROVIDE (end = .);
  . = DATA_SEGMENT_END (.);

  /DISCARD/ :
  { *(.stab*) *(.comment) *(.line) *(.debug*) *(.mdebug.*) *(.gnu.build.attributes*) *(.gnu.attributes)
    *(.gnu.linkonce.wi.*)
    *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*)
    *(.MIPS.abiflags) *(.reginfo)
  }

}
